# Copilot Instructions for This Repository

## 1. Purpose

This file defines how AI assistants (GitHub Copilot / Chat) should understand, navigate, and contribute to this
codebase. Audience: internal engineering team + AI coding tools. Scope: guidance, guardrails, conventions.

## 2. High-Level Project Snapshot

### 2.1 Domain

Hydrogen product passport & provenance platform (DUH-IT project) – transparent, automated, tamper-resistant verification
of hydrogen origin, composition and sustainability.

### 2.2 Core Objectives

- Track power batches & hydrogen batches and their process steps.
- Provide Proof of Origin & Proof of Sustainability.

### 2.3 Current Maturity

Early-stage: foundational services present; emissions & sustainability logic incomplete.

### 2.4 In Scope (current iteration)

- Batch lifecycle
- Process steps (production, bottling, transportation)
- Master data (companies, units, approvals)
- Composition calculation

### 2.5 Out of Scope (for now)

- Billing / settlement
- Advanced authorization granularity
- Full blockchain tokenization

## 3. Tech Stack & Tooling

### 3.1 Languages & Frameworks

- TypeScript
- NestJS (backend services & BFF)
- Angular 19 (frontend + SSR)
- Nx 20 (monorepo orchestration)

### 3.2 Tooling & Services

- Package Manager: npm (Node LTS 18+)
- Dockerized services: Nest apps, Angular, RabbitMQ, Postgres, MinIO, Keycloak
- Testing & Quality: Jest (unit/integration), Playwright (e2e), ESLint 9, Prettier 3, Danger, Sonar (via CI),
  license-checker
- Styling & UI: TailwindCSS 3, Angular Material, ECharts
- Messaging: RabbitMQ (`@nestjs/microservices`, `amqp-connection-manager`)
- Persistence: Prisma 6 (Postgres)
- Object Storage: MinIO
- Security: Keycloak (keycloak-angular, nest-keycloak-connect)
- Build/Bundling: Custom Webpack for Nest apps; Angular builder + Nx task graph
- Blockchain: Ethereum/Arbitrum placeholder (future integration)

## 4. Repository Structure (Curated)

### 4.1 Apps

- `apps/batch-svc` – Batch & process step domain operations
- `apps/bff` – Backend-for-Frontend API aggregator
- `apps/bff-e2e` – BFF end-to-end tests
- `apps/frontend` – Angular SSR-enabled client
- `apps/frontend-e2e` – Frontend end-to-end tests
- `apps/general-svc` – Master data (companies, units, approvals, types)
- `apps/process-svc` – Processing utilities (composition, step logic; WIP)

### 4.2 Libraries

- `libs/amqp` – Messaging patterns, entities, brokers, hydrogen composition utilities
- `libs/api` – Shared DTOs (proofs, emissions, classifications, latest batch queries)
- `libs/blockchain` – Placeholder for future on-chain integration
- `libs/configuration` – Centralized app configuration modules & env validation
- `libs/database` – Prisma schema, repositories, seed data
- `libs/storage` – MinIO file storage abstraction (documents, proofs assets)
- `libs/utils` – Small shared utilities (assertions)

### 4.3 Other

- `documentation/` – arc42 architecture docs
- `docker/` – Dockerfiles & compose for services and infra
- `nginx/` – Reverse proxy configuration (edge)

## 5. Architecture & Module Conventions

### 5.1 Layering

- General: Frontend → BFF → Backend Microservices → Persistence/Storage/Blockchain
- Backend Microservices: Controller → Service → Repository/Adapter
- Assemblers and mappers map DB entities → DTOs (e.g. `HydrogenComponentAssembler`)

### 5.2 Dependencies

- Apps depend on libs; libs never depend on apps
- Domain libs (`api`, `database`) avoid leaking infrastructure specifics

### 5.3 Cross-Cutting

- Configuration via `configuration` lib
- Security via Keycloak (BFF & frontend edge)
- Messaging via `amqp` lib (RabbitMQ request/response)
- Logging minimal (no structured logging yet)
- Tracing / metrics not implemented

### 5.4 Communication

- HTTP: Frontend ↔ BFF
- RabbitMQ: Inter-service requests (process steps, units, companies, production queries) using pattern enums

### 5.5 DTO vs Entity

- DTOs live in `libs/api`
- Backend entities live in `libs/amqp`
- Database entities generated by Prisma
- Message payload contracts enumerated in pattern files

## 6. Domain Glossary

Each term below is canonical. Keep additions concise; prefer linking to code (DTO / entity) rather than duplicating
logic.

**Amount** – Quantity of energy (power) or hydrogen produced within a 15-minute accounting period (kWh for power, kg/Nm³
for hydrogen).

**Accounting Period** – Fixed 15-minute interval used for balancing electricity injection/consumption and attributing
hydrogen production and compositions.

**Batch** – Generic homogeneous resource quantity (power or hydrogen) tracked for provenance; specialized as Hydrogen
Batch.

**Hydrogen Batch** – Hydrogen amount of a single Hydrogen Color produced within one accounting period; may later be part
of a mixed composition.

**Classification** – Grouping (e.g., energy source) used in proof sections for summarization.

**Hydrogen Color** – Classification of hydrogen by origin of consumed electricity (enum: GREEN, ORANGE, PINK, YELLOW,
MIX).

**Hydrogen Composition** – Fractional allocation of hydrogen colors inside a mixed (bottled) quantity.

**Hydrogen Production Unit (HPU)** – Electrolyzer installation converting water to hydrogen and oxygen; may yield green
hydrogen if powered by renewables.

**Hydrogen Storage Unit (HSU)** – Storage asset buffering produced hydrogen prior to bottling/transport.

**Hydrogen Producer** – Actor responsible for production, storage and bottling; has hydrogen-centric application views.

**MaStR Number** – German registry unique identifier for energy assets/operators.

**Origin (Hydrogen Origin)** – Set of power production units whose electricity fed a hydrogen batch.

**Power Access Approval** – Approval linking hydrogen and power producers plus the relevant production unit for
provenance tracing.

**Power Production Unit** – Registered electricity generation asset supplying power to hydrogen production.

**Process Step** – Recorded operation (production, bottling, transportation) with timestamps tied to a batch and
executing unit.

**Proof of Origin** – Aggregated lineage sections of hydrogen/power sources (DTO scaffolding present).

**Proof of Sustainability** – Emissions & sustainability metrics, aligned to GHG Protocol (logic pending).

**FIFO** – Planned allocation method ensuring oldest stored quantities are consumed/attributed first (for storage
depletion / composition attribution).

**Unit** – Physical asset in the hydrogen value chain (power production unit, hydrogen production unit, hydrogen storage
unit, transport container bundle).

## 7. Coding Standards

### 7.1 Core Principles

- Explicit public return types.
- Clear, intent-revealing names (domain nouns + verbs).
- Composition over inheritance; prefer small pure helpers.
- Immutability by default for DTOs & message payloads.
- Fail fast on invalid input (boundary validation, then trust internally).

### 7.2 Architecture & Structure

- Nest layering: Controller → Service → Repository/Adapter; assemblers map persistence → DTOs.
- Angular: standalone components, minimal template logic, smart vs presentational separation.
- File scope: one responsibility; soft limits (~200 LOC service; ~120 LOC component).
- Imports: prefer path aliases; re-export public surface via `index.ts`.
- Refactor when: >7 constructor deps, repeated logic (≥3), deep nesting (>3 levels), rising complexity (subjective >10).

### 7.3 Messaging & Contracts

- Validate inbound message DTOs (mirror HTTP validation rules).
- Prefer explicit field names; avoid ambiguous generic wrappers.
- See 9.2 for broker patterns & reliability gaps (idempotency, retries TBD).

### 7.4 Error / Logging / Security Pointers

- Throw plain Errors in domain/services; map to HTTP exceptions at controller boundary.
- Never swallow infrastructure errors—attach contextual (non-sensitive) metadata.
- Minimal logging until observability stack arrives; one log per failure path.
- No secrets, tokens, or PII in logs. See 9.3 (Security), 9.5 (Error Handling), 9.6 (Logging), 9.7 (Observability).

### 7.5 Clean Code & Documentation

Core Practices:

- Small Functions (<25 LOC typical) & single abstraction level.
- Guard clauses to reduce nesting; early returns preferred.
- Eliminate dead code & commented-out blocks immediately.
- Avoid boolean parameter flags—replace with explicit variant functions or config object.
- Intent > cleverness; readable O(n) > cryptic micro-optimizations.

Documentation & Readability:

- JSDoc only for exported APIs with non-obvious behavior or side‑effects.
- Example block when edge cases or non-trivial parameters exist.
- Prefer renaming over explanatory comments; comments focus on “why”, not “what”.

Extended Guidelines:

- Single responsibility per module; split when mixed concerns appear.
- One abstraction layer per function (no DB + formatting in same block).
- No magic literals—promote to well-named constants close to usage.
- Separate commands (side-effects) from queries (data retrieval).
- Limit public exports—keep internal helpers file-local until reuse proven.
- Consistent error semantics: domain vs infrastructure vs validation.
- Feature flags / experimental code isolated for easy removal.

### 7.6 Testing & Quality

- Pure function tests: boundary + nominal + failure cases.
- Service tests assert observable behavior (not internal implementation).
- Avoid mocking pure helpers; mock only IO (broker, storage, auth).
- At least one negative test per validation ruleset.
- See Section 8 for broader strategy (frameworks, placement, coverage target).

### 7.7 Anti-Patterns & Refactoring Signals

- God Service (>15 public methods or >500 LOC) → extract focused services.
- Anemic DTO accumulation (many optional unrelated fields) → redesign into nested types.
- Copy-paste across services → extract shared utility / domain helper.
- Overuse of `any` / broad `unknown` casts → narrow incrementally.
- Cyclomatic complexity growth / deep nesting → decompose or introduce predicates.
- N+1 data access or CPU-heavy loops in request path → batch or offload.

### 7.8 Delivery & Review Workflow

Code Review Focus:

- Clarity & correctness > cleverness.
- Single responsibility respected.
- Error paths contain sufficient (non-sensitive) context.
- Performance considerations justified by a measured need (or annotated as TODO if deferred).

## 8. Testing Strategy

### 8.1 Frameworks

- Jest (unit & integration)
- Playwright (frontend + BFF e2e)
- Supertest (via Nest testing utilities for HTTP endpoints)

### 8.2 Placement

- Co-located `*.spec.ts` near source for units
- Dedicated e2e apps: `frontend-e2e`, `bff-e2e`

### 8.3 Coverage

- At least 75%

### 8.4 Mocking Guidelines

- Mock only external IO: RabbitMQ, MinIO, Keycloak
- Avoid mocking pure assemblers / internal utilities

### 8.5 Sample Structure

```
libs/api/src/
  foo.service.ts
  foo.service.spec.ts
```

## 9. Cross-Cutting Concerns

### 9.1 Configuration

Centralized via `libs/configuration` providing modules + selective env validation. Key env vars: `DATABASE_URL`,
`POWER_ACCOUNTING_PERIOD_IN_SECONDS`, `HYDROGEN_ACCOUNTING_PERIOD_IN_SECONDS`, Keycloak client settings, RabbitMQ URL,
MinIO credentials. Environments: local (docker-compose) & CI; staging/prod not yet distinct. Feature flags: none (future
blockchain toggle). Secrets supplied via CI vars / local `.env`; never committed.

### 9.2 Messaging

Broker: RabbitMQ (RPC style) using Nest microservices. Patterns enumerated in
`libs/amqp/src/lib/broker/message-patterns/*.pattern.ts` (e.g. `ProcessStepMessagePatterns`). One queue per service
(`BrokerQueues`). Reliability gaps: no retries/DLQ, no idempotency (see Known Gaps). Versioning for message contracts
deferred; keep payload DTOs stable and evolve additively. Use `ClientProxy.send(pattern, payload)`; avoid
fire-and-forget for now. Testing: mock broker or use in-memory pattern handler in integration tests.

### 9.3 Security & Privacy

Authentication: Keycloak OIDC (frontend + BFF). Backend services trust BFF (no mTLS or service tokens yet).
Authorization: realm-role based; fine-grained domain authorization deferred. Input Validation: global `ValidationPipe` +
class-validator on DTOs. Secrets: never log; access via configuration module. Data minimization: Prisma schema limited
to essentials; no extraneous PII.

### 9.4 Validation Strategy

Boundary validation only: DTO classes with decorators; reject invalid input early. Assemblers / pure functions stay
unguarded (assume correct internal contract). When adding new endpoints or message handlers: 1) Define DTO in
`libs/api`, 2) Decorate for validation, 3) Enforce via controller pipe or global pipe, 4) Add unit test for invalid
payload rejection.

### 9.5 Error Handling

Types: validation, infrastructure (Prisma/broker), domain. Current approach: throw Nest HTTP exceptions or propagate
errors; no Result/Either wrapper yet. DO NOT swallow infrastructure errors—surface them. Messaging handlers should map
known domain issues to typed errors once domain error taxonomy exists (TODO:AI-CHECK to introduce taxonomy prior to
scaling handlers).

### 9.6 Logging

Minimal (Nest defaults). Structured logging intentionally deferred pending observability strategy. Guidelines
meanwhile: 1) Avoid logging secrets or PII, 2) Prefer warn/error only for actionable issues, 3) Avoid noisy debug
statements.

### 9.7 Observability & Performance

Current state: no metrics, tracing, dashboards, or backend caching.

### 9.8 Secrets Management

Source: environment variables (local `.env`, CI variables). Never commit secrets. Rotate credentials manually for now.
Rule: any new external dependency must list required secrets explicitly in PR description.

### 9.9 Versioning & Evolution

HTTP API: unversioned (introduce `/api/v1` when external consumers require stability). Messaging: additive evolution
(never repurpose a field with changed semantics). Document breaking change proposals via ADR before implementation. DTO
changes require: update `libs/api`, adjust consumers, add migration note in PR.

### 9.10 Correlation & Tracing (Deferred)

Correlation IDs not implemented.

### 9.11 Testing Support (Cross-Cutting)

Mock only external IO (RabbitMQ, MinIO, Keycloak). Prefer real assemblers & pure utilities. For messaging tests, supply
in-memory handler with identical pattern key to assert request/response contract.

### 9.12 Summary

This section supersedes prior distributed notes on configuration, messaging, security/privacy, logging &
observability/performance. Pointer sections below retained only to avoid broken references.

## 10. (Consolidated) Configuration & Environments

Moved to Section 9.1 (Configuration). Keep this section as a pointer to preserve numbering stability.

## 11. (Consolidated) Messaging & Async

Moved to Section 9.2 (Messaging). Reliability and versioning notes consolidated there.

## 12. API Design Guidelines

### 12.1 Style

Plural resource names; standard HTTP verbs mapped to CRUD semantics.

### 12.2 Versioning

Not implemented.

### 12.3 Pagination

Not implemented.

### 12.4 Errors

Raw Nest error responses currently.

### 12.5 Validation

Class-validator DTO annotations + global ValidationPipe.

### 12.6 Documentation

`@nestjs/swagger` present but OpenAPI generation not yet wired.

## 13. Frontend Conventions

### 13.1 Framework & Rendering

Angular 19 (standalone components) + SSR (`server.ts`).

### 13.2 State & Data

Angular Signals for local state; TanStack Angular Query for server data & caching.

### 13.3 Structure

Feature-oriented directories (components, services).

### 13.4 Styling

Tailwind utility-first; custom palette in `tailwind.config.js`.

### 13.5 Accessibility

Follow Angular Material accessibility guidance; ensure keyboard navigation & ARIA labeling on custom elements.

## 14. (Consolidated) Security & Privacy

Authentication, authorization, validation, secrets & data minimization now in Section 9.3 and 9.4.

## 15. (Consolidated) Performance & Observability

Moved to Section 9.7. Tracing & correlation deferred (see 9.10).

## 16. Dependency Management

### 16.1 Adding Dependencies

Justify in PR description; prefer widely-used standard libs.

### 16.2 Version Policy

Core frameworks pinned (Nx, Angular, Nest); other libs caret for minor updates.

### 16.3 Auditing

Run `npm audit` locally;

### 16.4 Deprecation

Document replacements & migration path in README or ADR.

## 17. Release & CI/CD Flow

### 17.1 Branching

Feature branches merged into `main`. Naming: `feature/JIRA_TICKET_NUMBER-short-kebab-summary` (also `fix/`, `chore/`,
`docs/`).

### 17.2 Pipeline Stages

danger → test → analysis → build → archive → deploy.

### 17.3 Quality Gates

ESLint, Prettier, unit tests, selected e2e, Sonar analysis (per service), license checker.

### 17.4 Versioning & Deployment

Semantic versioning policy. Deployment via Docker Compose (no advanced strategy yet).

## 18. Architecture / Decision Records

Arc42 documentation lives under `documentation/` and is included via `index.adoc`.

## 19. Example High-Quality Prompts

- Add a unit test for `HydrogenComponentAssembler` ensuring mixed color fractions sum correctly.
- Implement a new process step pattern in `libs/amqp` and consumer handler in `process-svc`.
- Create DTO + controller endpoint in `bff` aggregating latest batches (reuse existing repository layer via messaging).
- Add Playwright e2e test validating Keycloak login flow and a protected route in `frontend`.
- Draft an ADR proposal for introducing API versioning when external consumers arise.

## 20. Guardrails for AI Assistance

Must NOT:

- Invent non-existent modules/APIs.
- Introduce dependencies without PR note.
- Change public API contracts silently.
- Emit or infer secrets/credentials.

Should:

- Add/adjust tests with behavioral changes.
- Mark uncertainties as `TODO:AI-CHECK`.
- Keep patches minimal & lint-clean.
- Follow branch naming & commit clarity.

## 21. Known Gaps / WIP Areas

- Emission & sustainability calculations (GHG Protocol alignment pending).
- No logging/observability stack (intentional for now).
- No API versioning or standardized error envelope.
- No idempotency or retry policies on messaging.
- No ADR directory yet.
- Authorization granularity beyond Keycloak realm roles absent.
- Blockchain integration library empty placeholder.

## 22. Extensibility Recipes

Add New Library:

1. `npx nx g @nx/js:lib my-lib`
2. Export via `libs/my-lib/src/index.ts`
3. Add focused unit test & README stub

Add New Microservice:

1. `npx nx g @nx/nest:app my-svc`
2. Add configuration module & env validation
3. Implement health endpoint `/health` and minimal controller
4. Register broker client (see existing `main.ts` patterns)
5. Add Jest tests & sonar properties file

Add New Message Consumer:

1. Add pattern to appropriate `*.pattern.ts`
2. Inject `ClientProxy` where needed or create handler method in service
3. Implement controller/handler with validation pipe
4. Write integration test (Nest testing module + mocking broker or in-memory pattern)

## 23. Directory Quick Reference (Deprecated)

Canonical directory listing resides in Section 4. This section retained only as a pointer to avoid broken external
references.

## 24. Response Style & Interaction Preferences

### 24.1 Tone & Format

Concise, actionable, minimal fluff; weigh the pros and cons and explain your decision.

### 24.2 Clarifications

Ask only if assumption risk is high.

### 24.3 Output

Markdown with headings & code blocks; reference filenames with backticks.

### 24.4 Diffs

Provide minimal patches; no full file dumps unless creating a new file.

## 25. Ownership & Contacts

### 25.1 Code Owners

Fraunhofer IML engineering team (see contributors in `package.json`).

## 26. Appendix

### Key Documentation Paths

- Arc42 Index: `documentation/index.adoc`
- Introduction (TBD): `documentation/01-introduction-and-goals.adoc`
- Building Block View: `documentation/02-building-block-view.adoc`
- Runtime View (TBD): `documentation/03-runtime-view.adoc`
- Deployment View: `documentation/04-deployment-view.adoc`
- Tutorial (TBD): `documentation/05-tutorial.adoc`
- ADR Index: (TBD once `documentation/adr` exists)
- API Docs: (Enable via `@nestjs/swagger` – not yet generated)
- Runbook / Ops: (TBD)
